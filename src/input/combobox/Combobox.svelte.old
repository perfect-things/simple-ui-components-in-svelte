<div
	class="input combobox {className}"
	class:open="{opened}"
	class:has-error="{error}"
	class:label-on-the-left="{!!labelOnTheLeft}"
	class:multiselect
	bind:this="{element}">

	<Label {label} {disabled} for="{_id}"/>
	<Info msg="{info}" />

	<div class="input-inner" class:disabled>
		<InputError id="{errorMessageId}" msg="{error}" />

		<div class="input-row" title="{valueName}">
			<Button
				link
				icon="dots"
				class="combobox-button"
				tabindex="-1"
				on:mousedown="{onIconMouseDown}"
				on:click="{onIconClick}"/>

			<ComboInput
				{id}
				{disabled}
				{required}
				guid="{uuid}"
				placeholder="{placeholder ? placeholder : (multiselect ? 'Select...' : '')}"
				expanded="{opened}"
				bind:value="{inputValue}"
				bind:element="{inputElement}"
				on:event="{onInputEvent}"/>

			<!-- <input
				type="text"
				role="combobox"
				aria-autocomplete="list"
				aria-controls="combobox-list-{gui}"
				aria-expanded="{opened}"
				aria-invalid="{error}"
				aria-errormessage="{error ? errorMessageId : undefined}"
				aria-required="{required}"
				autocomplete="off"
				bind:value="{inputValue}"

				{disabled}
				placeholder="{placeholder ? placeholder : (multiselect ? 'Select...' : '')}"
				id="{_id}"
				{...$$restProps}

				bind:this="{inputElement}"
				on:input="{oninput}"
				on:focus="{onfocus}"
				on:mousedown="{open}"
				on:click="{open}"
				on:blur="{onblur}"
				on:keydown|capture="{onkeydown}"> -->
		</div>
	</div>
</div>


<!-- svelte-ignore a11y-interactive-supports-focus a11y-click-events-have-key-events -->
{#if opened}
	<div
		id="combobox-list-{uuid}"
		class="combobox-list {opened ? '' : 'hidden'}"
		class:multiselect
		class:empty="{!filteredData.length && !shouldShowNewItem}"
		role="listbox"
		on:mousedown={onListMouseDown}
		bind:this="{listElement}">
		{#if filteredData.length}
			{#each groupedData as group}
				{#if group.name}
					<div class="combobox-list-header">{group.name}</div>
				{/if}
				{#if group.items}
					{#each group.items as item}
						<div
							role="option"
							aria-selected="{item.idx === highlightIndex}"
							aria-checked="{item.checked}"
							class:checked="{item.checked}"
							class="combobox-list-item"
							class:in-group="{!!item.group}"
							class:selected="{item.idx === highlightIndex}"
							on:click="{e => onclick(item, e)}"
							on:mouseenter="{() => highlightIndex = item.idx}"
							on:mousedown|preventDefault
							on:mouseup="{e => onclick(item, e)}"
							on:touchstart="{touchStart}"
							on:touchend="{touchEnd}"
							>
							{#if multiselect}
								{#if item.checked}
									<Icon name="checkboxChecked" />
								{:else}
									<Icon name="checkbox" />
								{/if}
							{/if}
							{@html item.highlightedName || item.name}
						</div>
					{/each}
				{/if}
			{/each}
		{:else if allowNew}
			<div class="combobox-list-empty">No items found</div>
		{/if}

		{#if shouldShowNewItem}
		<div class="combobox-list-header">Create new item</div>
			<div
				role="option"
				aria-selected="{highlightIndex === filteredData.length}"
				class="combobox-list-item"
				class:selected="{highlightIndex === filteredData.length}"
				on:click="{e => onclick({ name: inputElement.value, idx: filteredData.length }, e)}">
					{inputElement.value}
			</div>
		{/if}
	</div>
{/if}


<script>
import { afterUpdate, createEventDispatcher, onDestroy } from 'svelte';
import { Filter, Items } from './store';
import { emphasize, highlight, groupData, findValueInSource, hasValueChanged, alignDropdown } from './utils';
import { deepCopy, fuzzy, guid, isMobile } from '../../utils';
import { Icon } from '../../icon';
import { Button } from '../../button';
import { Info } from '../../info-bar';
import { InputError } from '../input-error';
import { Label } from '../label';
import ComboInput from './ComboInput.svelte';


let className = '';
export { className as class };
export let id = '';
export let disabled = false;
export let required = undefined;
export let allowNew = undefined;
export let showOnFocus = undefined;
export let hideOnResize = undefined;
export let label = '';
export let error = undefined;
export let info = undefined;
export let labelOnTheLeft = undefined;
export let placeholder = undefined;
export let multiselect = undefined;

export let items = [];
export let value = null;

export let element = undefined;
export let inputElement = undefined;
export let listElement = undefined;


const uuid = guid();



$:_id = id || name || guid();
$:valueMatchesItem = (filteredData && filteredData.length && filteredData.find(i => i.name === inputElement.value));
$:shouldShowNewItem = allowNew && inputElement && inputElement.value && !valueMatchesItem;
const dispatch = createEventDispatcher();
const errorMessageId = guid();

let inputValue = setValue(value);

let valueName = value && value.name || '';
let opened = false;
let hasEdited = false;
let highlightIndex = 0;
let filteredData = [], groupedData = [];
let originalText = '';
let hasSetValue = true;
let isSelecting = false;
let isHiding = false;



onDestroy(() => {
	if (listElement) listElement.remove();
});


afterUpdate(() => {
	Items.set(items);
	Filter.set('');
	setInitialValue();
});


function setValue (_value) {
	if (multiselect) {
		if (!Array.isArray(_value)) _value = [_value];
		return _value.map(i => i.name || i).join(', ');
	}
	return _value && _value.name || '';
}


function onInputEvent (e) {
	console.log(e);
}












function filter () {
	let filtered = deepCopy(items);
	if (hasEdited && inputElement.value) {
		const q = inputElement.value.toLowerCase().trim();
		filtered = filtered
			.filter(item => fuzzy(item.name, q))
			.map(item => {
				item.highlightedName = emphasize(item.name, q);
				item.score = 1;
				if (item.name.toLowerCase().includes(q)) item.score = 2;
				if (item.name.includes(q)) item.score = 3;
				if (item.name.toLowerCase() === q) item.score = 4;
				if (item.name === q) item.score = 5;
				return item;
			})
			.sort((a, b) => b.score - a.score);
	}
	groupedData = groupData(filtered);
	if (multiselect) setSelectedItems();

	const filteredAndSorted = [];
	let idx = 0;
	groupedData.forEach(g => {
		g.items.forEach(i => {
			i.idx = idx++;
			filteredAndSorted.push(i);
		});
	});
	filteredData = filteredAndSorted;

	highlightIndex = 0;
	highlight(listElement);
	alignDropdown(listElement, inputElement);
}


function setSelectedItems () {
	const selectedIds = value.map(i => i.id || i.name || i);
	selectedItems = items.filter(i => selectedIds.includes(i.id || i.name || i));

	groupedData.forEach(g => {
		g.items.forEach(i => {
			i.checked = selectedIds.includes(i.id || i.name || i);
		});
	});
	groupedData = groupedData;
}

function open (e) {
	const eType = e && e.type;
	const clickOnMobile = isMobile() && eType === 'click';
	const mousedownElsewhere = !isMobile() && eType === 'mousedown';

	if (e && !(clickOnMobile || mousedownElsewhere)) return;
	if (e && mousedownElsewhere && multiselect && opened) return close();
	if (opened) return;

	opened = true;
	hasEdited = false;
	if (multiselect) {
		inputElement.value = '';
		valueName = '';
		filter();
	}
	requestAnimationFrame(() => {
		if (listElement && listElement.parentElement !== document.body) {
			document.body.appendChild(listElement);
		}
		addEventListeners();
		highlight(listElement);
		alignDropdown(listElement, inputElement, e);
	});
}


function close () {
	if (!opened) return;
	removeEventListeners();
	opened = false;
	isSelecting = false;
	if (multiselect) valueName = selectedItems.map(i => i.name || i).join(', ');
}



function selectSingle (item) {
	if (multiselect || hasSetValue) return;
	const oldValue = deepCopy(value);

	if (!item) {
		if (filteredData[highlightIndex]) item = filteredData[highlightIndex];
		else if (allowNew) item = { name: inputElement.value };
		else if (value && value.name && inputElement.value !== value.name) valueName = value.name;
	}
	if (item) {
		value = findValueInSource(item, originalItems) || item;
		if (value && value.name && (inputElement.value !== value.name || valueName !== value.name)) {
			inputElement.value = value.name;
			valueName = value.name;
		}
		originalText = '';
	}

	hasSetValue = true;
	filter();

	if (hasValueChanged(oldValue, value)) dispatch('change', { value, oldValue });
	requestAnimationFrame(() => {
		inputElement.focus();
		close();
	});

}

function selectMultiselect (item) {
	const oldValue = deepCopy(value);
	selectedItems = selectedItems || [];
	if (!item.checked) selectedItems.push(item);
	else {
		const _item = item.id || item.name || item;
		selectedItems = selectedItems.filter(i => (i.id || i.name || i) !== _item);
	}
	value = findValueInSource(selectedItems, originalItems) || [];

	setSelectedItems();

	if (hasValueChanged(oldValue, value, true)) dispatch('change', { value, oldValue });
	requestAnimationFrame(() => inputElement.focus());
}


function setInitialValue () {
	if (!filteredData || !filteredData.length) return;

	if (!value || (multiselect && !value.length)) return;

	if (multiselect) {
		if (!Array.isArray(value)) value = [value];
		setSelectedItems();

		if (opened) valueName = '';
		else valueName = selectedItems.map(i => i.name || i).join(', ');
	}
	else {
		const itemId = value.id || value.name || value;
		if (itemId) {
			console.log(filteredData);
			const idx = filteredData.findIndex(i => (i.id || i.name || i) === itemId);
			if (idx > -1) {
				highlightIndex = idx;
				inputElement.value = filteredData[highlightIndex].name;
			}
			highlight(listElement);
		}
		else inputElement.value = '';
	}
}


function up () {
	if (!opened) return open();
	let idx = highlightIndex - 1;
	while (idx > 0 && !filteredData[idx]) idx -= 1;
	if (idx !== highlightIndex && filteredData[idx]) {
		highlightIndex = filteredData[idx].idx;
		highlight(listElement);
	}
}


function down () {
	if (!opened) return open();
	let idx = highlightIndex + 1;
	while (idx < filteredData.length - 1 && !filteredData[idx]) idx += 1;

	let item = filteredData[idx];

	if (shouldShowNewItem && idx === filteredData.length) {
		item = { idx: filteredData.length };
	}

	if (idx !== highlightIndex && item) {
		highlightIndex = item.idx;
		highlight(listElement);
	}
}


function revert () {
	if (multiselect) return;	// in multiselect selection is applied when item is clicked
	if (originalText && originalText !== inputElement.value) inputElement.value = originalText;
	else if (value && value.name) inputElement.value = value.name;
	else inputElement.value = '';
}



/*** EVENT LISTENERS ******************************************************************************/
function onfocus () {
	originalText = inputElement.value;
	if (showOnFocus) open();
}


function oninput () {
	open();
	requestAnimationFrame(filter);
	hasEdited = true;
	hasSetValue = false;
}


function onblur () {
	if (isSelecting) return;
	if (opened && !inputElement.value) return revert();
	selectSingle();
}


function onListMouseDown () {
	isSelecting = true;
}


function touchStart (e) {
	const el = e.target.closest('.combobox-list-item');
	el.classList.add('blinking');
}


function touchEnd (e) {
	const el = e.target.closest('.combobox-list-item');
	requestAnimationFrame(() => el.classList.remove('blinking'));
}


function onclick (item, e) {
	// click should only be handled on touch devices
	if (isMobile() && e.type !== 'click') return e.preventDefault();
	if (!isMobile() && e.type === 'click') return;

	if (multiselect) selectMultiselect(item);
	else {
		hasSetValue = false;
		selectSingle(item);
	}
}


function onkeydown (e) {
	if (e.key === 'Tab') return close();

	const fnmap = {
		ArrowDown: down,
		ArrowUp: up,
		Escape: onEsc,
		' ': onSpace,
		Enter: onEnter,
	};

	if (typeof fnmap[e.key] === 'function') {
		e.preventDefault();
		fnmap[e.key](e);
	}
}


function onEnter () {
	if (!opened) return open();
	if (multiselect) return requestAnimationFrame(close);

	hasSetValue = false;
	selectSingle();
}


function onSpace (e) {
	if (!multiselect || !opened) return;
	const item = filteredData[highlightIndex];
	onclick(item, e);
}


function onEsc (e) {
	if (opened) {
		e.stopPropagation();
		revert();
		filter();
		inputElement.focus();
		return close();
	}
	dispatch('keydown', e);
}


function onIconMouseDown () {
	isHiding = opened;
}


function onIconClick () {
	if (isHiding) close();
	else open();

	isHiding = false;
	if (inputElement) inputElement.focus();
}


function onResize () {
	if (!opened) return;
	if (hideOnResize) return;
	inputElement.blur();
	return close();
}


function onViewportResize () {
	if (!opened) return;
	alignDropdown(listElement, inputElement);
}


function onDocumentClick (e) {
	const notEl = element && !element.contains(e.target);
	const notList = listElement && !listElement.contains(e.target);
	if (open && notEl && notList) close();
}


function addEventListeners () {
	window.addEventListener('resize', onResize);
	document.addEventListener('click', onDocumentClick, true);
	window.visualViewport.addEventListener('resize', onViewportResize);
}


function removeEventListeners () {
	window.removeEventListener('resize', onResize);
	document.removeEventListener('click', onDocumentClick, true);
	window.visualViewport.removeEventListener('resize', onViewportResize);
}
/*** EVENT LISTENERS ******************************************************************************/

</script>
